#' Make tree views for the mutation / lineage data
#'
#' @param   ggtree_data   Tree data for passing to \code{ggtree}.
#' @param   branch_col    Scalar string. A statistic for which the trees provide a summary. The name
#'   of a column within \code{ggtree_data}.
#' @param   n_leaves    Scalar integer. The number of leaves in the tree.
#' @param   lins    List. Defines the virus lineages that are under study. Three entries are
#'   present. \code{lins$lineages} a string vector of the lineages. \code{lins$nodes} an integer
#'   vector of node numbers, these correspond to nodes in \code{ggtree_data$node}.
#'   \code{lins$node_names} a string vector giving the name of the lineage. For \code{nodes} and
#'   \code{node_names} the order of entries matches that for \code{lins}.
#' @param   sc0,cmuts   Data-frames.
#' @param   heatmap_width,heatmap_lab_offset    Parameters for positioning of the heatmap.
#' @param   mut_regex   Regular expression. Defines the mutations under study here.
#' @param   colours    Vector of colours.
#' @param   colour_limits   Min and max values for the colours.
#'
#' @return  A list with several entries. Each entry is a \code{ggtree} object. The list names are
#'   "noninteractive", "with_interactivity_data", "with_heatmap", "interactive".

create_trees <- function(ggtree_data,
                         branch_col,
                         n_leaves,
                         lins,
                         sc0,
                         cmuts,
                         heatmap_width,
                         heatmap_lab_offset,
                         mut_regex = NULL,
                         colours = NULL,
                         colour_limits = NULL) {
  shapes <- c(
    Y = "\U2B24",
    N = "\U25C4"
  )

  tree_list <- list()

  tree_list$noninteractive <- create_noninteractive_ggtree(
    ggtree_data = ggtree_data,
    branch_col = branch_col,
    lins = lins,
    shapes = shapes,
    colours = colours,
    colour_limits = colour_limits
  )

  tree_list$with_interactivity_data <- append_interactivity_data(
    tree_list[["noninteractive"]],
    branch_col = branch_col,
    sc0 = sc0,
    cmuts = cmuts,
    mut_regex = mut_regex
  )

  genotype <- extract_genotype_data(
    ggobj = tree_list[["with_interactivity_data"]],
    n_leaves = n_leaves,
    mut_regex = mut_regex
  )

  tree_list$with_heatmap <- append_heatmap(
    ggobj = tree_list[["with_interactivity_data"]],
    genotype = genotype,
    heatmap_width = heatmap_width,
    heatmap_lab_offset = heatmap_lab_offset
  )

  tree_list$interactive <- create_interactive_ggtree(
    tree_list[["with_heatmap"]],
    branch_col = branch_col,
    cluster_size_range = c(2, 16),
    shapes = shapes,
    colours = colours,
    colour_limits = colour_limits
  )

  tree_list
}

#' Save the tree views to files
#'
#' @param   tree_list   List of \code{ggtree} objects. The "noninteractive" and "interactive"
#'   entries will be saved to an external file. As generated by \code{create_trees}.
#' @param   branch_col   Scalar string. The name of the statistic that is under study here (e.g.,
#'   "logistic_growth_rate" or "clock_outlier"). This name will be used in the output file paths.
#' @param   output_dir   Scalar string. The directory where the plots will be saved.
#' @param   output_format   String (either \code{rds} or \code{html} or both). Default: both. Which
#'   file format(s) should the interactive tree plot(s) be placed? For \code{rds}, a \code{ggtree}
#'   object will be placed in an \code{rds} file. For \code{html}, a \code{htmlwidget} will be
#'   placed in a \code{html} file.
#' @param   include_date   Boolean. Should the file-paths include the current date?
#' @inheritParams   create_trees
#'
#' @return   A named vector containing the file paths that were generated.

save_trees <- function(tree_list,
                       branch_col,
                       n_leaves,
                       output_dir,
                       output_format = c("rds", "html"),
                       include_date = FALSE) {
  output_format <- match.arg(output_format, several.ok = TRUE)
  required_filetypes <- c(
    "noninteractive",
    c(rds = "interactive_rds", html = "interactive_html")[output_format]
  )

  basename_prefix <- if (include_date) {
    glue::glue("tree-{branch_col}-{Sys.Date()}")
  } else {
    glue::glue("tree-{branch_col}")
  }

  basenames <- c(
    noninteractive = glue::glue("{basename_prefix}.svg"),
    interactive_rds = glue::glue("{basename_prefix}.rds"),
    interactive_html = glue::glue("{basename_prefix}.html")
  )[required_filetypes]

  files <- stats::setNames(
    file.path(output_dir, basenames),
    required_filetypes
  )

  plot_height <- max(14, floor(n_leaves / 10))

  ggplot2::ggsave(
    tree_list[["noninteractive"]],
    filename = files[["noninteractive"]],
    height = plot_height,
    width = 16,
    limitsize = FALSE
  )

  if ("rds" %in% output_format) {
    saveRDS(
      tree_list[["interactive"]],
      file = files[["interactive_rds"]]
    )
  }

  if ("html" %in% output_format) {
    widget <- create_widget(
      tree_list[["interactive"]],
      width_svg = 15,
      height_svg = plot_height
    )

    htmlwidgets::saveWidget(
      widget,
      file = files[["interactive_html"]],
      title = glue::glue("SARS CoV 2 scan {Sys.Date()}")
    )
  }

  invisible(files)
}

#' Create a non-interactive \code{ggtree} object for presenting mutation and lineage data
#'
#' @inheritParams   create_trees
#' @param   shapes    Shapes for the branches and leaves in the tree.
#'
#' @return  A \code{ggtree} object.

create_noninteractive_ggtree <- function(ggtree_data,
                                         branch_col,
                                         lins,
                                         shapes,
                                         colours,
                                         colour_limits) {
  gtr1 <- ggtree::ggtree(
    ggtree_data,
    ggplot2::aes_string(colour = branch_col),
    ladderize = TRUE,
    right = TRUE,
    continuous = TRUE
  )

  gtr1.1 <- gtr1 +
    ggplot2::scale_color_gradientn(
      name = gsub(branch_col, pattern = "_", replacement = " "),
      colours = colours,
      limits = colour_limits,
      oob = scales::squish
    ) +
    ggplot2::geom_point(
      ggplot2::aes_string(
        color = branch_col,
        size = "cluster_size",
        shape = "as.factor(internal)"
      ),
      data = gtr1$data
    ) +
    ggplot2::scale_shape_manual(
      name = NULL,
      labels = NULL,
      values = shapes
    ) +
    ggplot2::scale_size(
      name = "Cluster size",
      range = c(2, 16)
    ) +
    ggplot2::guides(shape = "none") +
    ggplot2::ggtitle(glue::glue("{Sys.Date()}, colour: {branch_col}")) +
    ggplot2::theme(legend.position = "top")

  for (i in seq_along(lins[["lineages"]])) {
    if (!is.na(lins[["nodes"]][i])) {
      gtr1.1 <- gtr1.1 +
        ggtree::geom_cladelabel(
          node = lins[["nodes"]][i],
          label = lins[["node_names"]][i],
          offset = .00001,
          colour = "black"
        )
    }
  }

  gtr1.1
}

#' Adds data to a ggtree object to allow mouse-over tooltips etc when presented interactively
#'
#' @param   ggobj   A \code{ggtree} object.
#' @param   branch_col    Scalar string. The name of a column within \code{ggobj$data} defining the
#'   statistic under study here (`logistic_growth_rate`, `clock_outlier`).
#' @inheritParams   create_trees
#'
#' @return  A ggtree object. The \code{$data} entry has additional entries (\code{mouseover},
#'   \code{colour_var}, \code{defmuts}, \code{allmuts}) that are used when presented interactively
#'   by \code{ggiraph}.

append_interactivity_data <- function(ggobj,
                                      branch_col,
                                      sc0,
                                      cmuts,
                                      mut_regex) {
  # make mouseover info
  ## standard meta data
  ttdfs <- apply(ggobj$data, 1, FUN = function(x) {
    z <- as.list(x)
    lgr <- as.numeric(z$logistic_growth_rate)
    # TODO: replace with() with explicit z$cluster_id etc
    y <- with(
      z,
      data.frame(
        `Cluster ID` = glue::glue("#{cluster_id}"),
        `Cluster size` = cluster_size,
        `Date range` = date_range,
        `Example sequence` = label,
        `Logistic growth` = paste0(
          ifelse(lgr > 0, "+", ""),
          round(lgr * 100), "%"
        ),
        `Mol clock outlier` = clock_outlier,
        `Lineages` = lineages
      )
    )
    y <- t(y)
    colnames(y) <- ""
    tryCatch(
      paste(knitr::kable(y, "simple"), collapse = "\n"),
      error = function(e) paste(knitr::kable(y, "markdown"), collapse = "\n")
    )
  })

  ## table with geo composition
  ttregtabs <- ggobj$data$region_summary #
  ## cocirc
  ttcocirc <- ggobj$data$cocirc_summary #

  ## defining muts
  ttdefmuts <- sapply(match(ggobj$data$cluster_id, sc0$cluster_id), function(isc0) {
    if (is.na(isc0)) {
      return("")
    }
    paste(
      sep = "\n",
      "Cluster branch mutations:",
      gsub(
        x = tryCatch(
          stringr::str_wrap(
            paste(
              collapse = " ",
              sort_mutations(cmuts[[as.character(sc0$node_number[isc0])]]$defining)
            ),
            width = 60
          ),
          error = function(e) browser()
        ),
        pattern = " ",
        replacement = ", "
      ),
      "\n"
    )
  }) # end of sapply

  ttallmuts <- sapply(match(ggobj$data$cluster_id, sc0$cluster_id), function(isc0) {
    if (is.na(isc0)) {
      return("")
    }
    paste(
      sep = "\n",
      "All mutations:",
      gsub(
        x = stringr::str_wrap(
          paste(
            collapse = " ",
            sort_mutations(cmuts[[as.character(sc0$node_number[isc0])]]$all)
          ),
          width = 60
        ),
        pattern = " ",
        replacement = ", "
      ),
      "\n"
    )
  }) # end of sapply

  ggobj$data$defmuts <- ttdefmuts
  ggobj$data$allmuts <- ttallmuts
  if (!is.null(mut_regex)) {
    for (mre in mut_regex) {
      i <- which(grepl(ggobj$data$allmuts, pattern = mre))
      ggobj$data[[mre]] <- grepl(ggobj$data$allmuts, pattern = mre)
    }
  }

  # make html widget
  ggobj$data$mouseover <- sapply(seq_along(ttdfs), function(i) {
    paste0(
      "Statistics:\n", ttdfs[i],
      "\n\nGeography:\n", ttregtabs[i],
      "\n\nCo-circulating with:\n", ttcocirc[i],
      "\n\n", ttdefmuts[i],
      "\n", ttallmuts[i],
      "\n",
      collapse = "\n"
    )
  })
  ggobj$data$colour_var <- ggobj$data[[branch_col]]

  ggobj
}

#' Extract the data about viral genotypes from a \code{ggtree} object
#'
#' @param   ggobj   A \code{ggtree} object, as generated by \code{append_interactivity_data}. The
#'   \code{data} entry for this object should contain the columns "node", "label" and a column for
#'   each of the \code{mut_regex} values.
#' @param   mut_regex   String. Regular expression defining the mutations under study here. This
#'   should be a subset of the column-names in \code{ggobj$data}.
#' @inheritParams   create_trees
#'
#' @return   Data-frame.

extract_genotype_data <- function(ggobj,
                                  n_leaves,
                                  mut_regex) {
  genotype <- as.data.frame(
    ggobj$data[
      ggobj$data$node <= n_leaves,
      c("label", mut_regex)
    ]
  )
  rownames(genotype) <- genotype$label
  genotype <- genotype[, -1, drop = FALSE]

  genotype
}

#' Adds a heatmap to the right of a ggtree object
#'
#' @param   ggobj   A ggtree object.
#' @param   genotype    The heatmap data.
#' @inheritParams   create_trees
#'
#' @return  A \code{ggtree} / \code{gg} / \code{ggplot} object with an appended heatmap.

append_heatmap <- function(ggobj,
                           genotype,
                           heatmap_width = 1,
                           heatmap_lab_offset = 0) {
  ggtree::gheatmap(
    p = ggobj,
    data = genotype,
    width = heatmap_width,
    offset = 0.0005,
    colnames_angle = -90,
    colnames_position = "top",
    colnames_offset_y = heatmap_lab_offset,
    legend_title = "Genotype"
  )
}

#' Converts a \code{ggtree} object into a \code{ggiraph} object with interactive potential
#'
#' @param   ggobj   A \code{ggtree} object.
#' @param   branch_col    Scalar string. Name of the column in \code{ggobj$data} that we are
#'   creating the plot for.
#' @param   cluster_size_range    Numeric (length-2). min and max values for cluster sizes on the
#'   chart.
#' @inheritParams   create_noninteractive_ggtree
#'
#' @return  A  \code{ggtree} object with interactive data for presentation by
#'   \code{ggiraph::girafe}.

create_interactive_ggtree <- function(ggobj,
                                      branch_col,
                                      cluster_size_range,
                                      shapes,
                                      colours,
                                      colour_limits) {
  ggobj +
    ggiraph::geom_point_interactive(
      ggplot2::aes(
        x = .data$x,
        y = .data$y,
        color = .data$colour_var,
        tooltip = .data$mouseover,
        data_id = .data$node,
        size = .data$cluster_size + 1,
        shape = as.factor(.data$internal)
      )
    ) +
    ggplot2::scale_shape_manual(
      name = NULL,
      labels = NULL,
      values = shapes
    ) +
    ggplot2::scale_size(
      name = "Cluster size",
      range = cluster_size_range
    ) +
    ggplot2::scale_color_gradientn(
      name = stringr::str_to_title(
        gsub(branch_col, pattern = "_", replacement = " ")
      ),
      colours = colours,
      limits = colour_limits,
      oob = scales::squish
    ) +
    ggplot2::theme(legend.position = "top")
}

#' Sorts a vector of mutations
#'
#' @param   muts    String. Vector of mutations. Each string must be a separate mutation
#'   (e.g., "S:A243del"). The mutations have a prefix ("S:", "N:") and a positional description of
#'   the protein-level mutation ("T205I" for Thr to Ile mutation at position 205).
#'
#' @return  String. A vector of the same length as \code{muts}. The mutations are sorted by prefix
#'   and then by the location of the mutation.

sort_mutations <- function(muts) {
  if (length(muts) == 0) {
    return("")
  }
  pre <- sapply(strsplit(muts, split = ":"), "[", 1)
  upres <- sort(unique(pre))
  sorted_mutations <- do.call(c, lapply(upres, function(.pre) {
    .muts <- muts[pre == .pre]
    .muts1 <- sapply(strsplit(.muts, split = ":"), "[", 2)
    sites <- regmatches(
      .muts1,
      regexpr(.muts1,
        pattern = "[0-9]+"
      )
    )
    o <- order(as.numeric(sites))
    .muts[o]
  }))

  sorted_mutations
}
